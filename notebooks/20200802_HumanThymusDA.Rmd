---
title: "Milo on human thymus"
output: html_notebook
---

```{r}
library(SingleCellExperiment)
library(tidyverse)
library(igraph)
library(scran)

devtools::load_all("~/miloR/")

## Setup to use python in Rmd
library(reticulate)
reticulate::use_condaenv("emma_env")

theme_dimred <- function( ... ){
  theme(axis.ticks =element_blank(), axis.text = element_blank(), plot.title = element_text(hjust=0.5), ... )
  }
```

```{python}
import scanpy as sc
import pandas as pd
import numpy as np
## To show plots inline
import matplotlib.pyplot as plt
import sys,os
plt.switch_backend('agg')
sys.path.insert(1, '/nfs/team205/ed6/bin/thATAC/preprocess_utils/')
import atac_utils 
import scipy.sparse
from pathlib import Path

# sc._settings.ScanpyConfig.figdir = Path(r.outdir)
```


### Load data

Load anndata object, downloaded from [here](https://zenodo.org/record/3572422#.XsY2h5NKhQI) following the link from [Park et al. 2020](10.1126/science.aay3224)

```{python}
rna_adata = sc.read_h5ad("/nfs/team205/ed6/data/Park_scRNAseq/HTA08.v01.A06.Science_human_tcells.raw.h5ad")
rna_adata.X = rna_adata.raw.X
rna_adata.X = scipy.sparse.csc_matrix(rna_adata.X)
```

Load MOFA projection, to use as reduced dimensionality object

```{r}
mofa_dims <- read.csv("/nfs/team205/ed6/data/thymus_data/thymus_MOFA_projection.csv") %>%
  column_to_rownames("cell")

## Filter just the scRNA-seq cells and factors 4 knn graoh construciton
mofa_dims <- as.matrix(mofa_dims[rownames(py$rna_adata$obs),1:5])
```

Convert `anndata` to `SingleCellExperiment` object 

```{r}
adata <- py$rna_adata
cnt <- t(adata$X)
rownames(cnt) <- adata$var_names$to_list()
colnames(cnt) <- adata$obs_names$to_list()
logCnt <- log2(cnt + 1)
pca <- prcomp(t(vx))

# Create the SingleCellExperiment object
sce <- SingleCellExperiment(assay=list(counts=cnt, logcounts=logCnt), colData = adata$obs)

reducedDim(sce) <- mofa_dims
reducedDimNames(sce) <- "MOFA"
sce

## Save SingleCellExperiment
saveRDS(sce, "/nfs/team205/ed6/data/Park_scRNAseq/HTA08.v01.A06.Science_human_tcells.SingleCellExperiment.RDS")
```

```{r}
sce <- readRDS("~/Downloads/HTA08.v01.A06.Science_human_tcells.SingleCellExperiment.RDS")
```


Make Milo object
```{r}
milo <- Milo(sce)
```


## Build KNN graph

For now I use scran function instead of `buildGraph` from package because it's very slow

```{r}
## Rename MOFA dim reduction as PCA so buildGraph can find it
reducedDim(milo, "PCA") <- reducedDim(milo)
# 
# library(BiocNeighbors)
# library(BiocParallel)
# milo <- buildGraph(milo, k = 30)

knn_graph <- buildKNNGraph(reducedDim(milo, "MOFA"), k=30, d=NA, transposed=TRUE)
# graph(milo)[["graph"]] <- knn_graph
miloR::graph(milo) <- knn_graph
```


## Test for differential abundance by age

Sample neighborhoods with refined sampling scheme

```{r}
devtools::load_all("~/miloR")
# milo@neighbourhoods <- list()
milo <- makeNeighbourhoods(milo, prop=0.05, k = 30, d=5, reduced_dims = "PCA")
length(milo@neighbourhoods)
```


Make model matrix for testing. I use Age as an ordinal variable for testing.

```{r}
th.meta <- data.frame(colData(sce)[,c("Sample","Age")]) %>%
  distinct() %>%
  rownames_to_column() %>%
  select(Sample, Age) %>%
  column_to_rownames("Sample")
th.model <- model.matrix(~  Age, data=th.meta)
th.model
```


```{r}
milo <- countCells(milo, 
                   data = data.frame(colData(milo)[,c("Sample","Age")]),
                   samples = "Sample")
```

```{r}
graph_spatialFDR <- function(neighborhoods, graph, pvalues, connectivity='vertex', pca=NULL){
  # input a set of neighborhoods as a list of graph vertices
  # the input graph and the unadjusted GLM p-values
  #' neighborhoods: list of vertices and their respective neighborhoods
  #' graph: input kNN graph
  #' pvalues: a vector of pvalues in the same order as the neighborhood indices
  #' connectivity: character - edge or vertex to calculate neighborhood connectivity or distance to use average Euclidean distance
  #' pca: matrix of PCs to calculate Euclidean distances, only required when connectivity == distance
  # Discarding NA pvalues.
  haspval <- !is.na(pvalues)
  if (!all(haspval)) {
      coords <- coords[haspval, , drop=FALSE]
      pvalues <- pvalues[haspval]
  }
    
  # define the subgraph for each neighborhood then calculate the vertex connectivity for each
  # this latter computation is quite slow - can it be sped up?
  subgraphs <- lapply(1:length(neighborhoods[haspval]),
                         FUN=function(X) induced_subgraph(graph, neighborhoods[haspval][[X]]))
  # now loop over these sub-graphs to calculate the connectivity - this seems a little slow...
  if(connectivity == "vertex"){
    t.connect <- lapply(subgraphs, FUN=function(EG) vertex_connectivity(EG))
  } else if(connectivity == "edge"){
    t.connect <- lapply(subgraphs, FUN=function(EG) edge_connectivity(EG))
  } else if(connectivity == "distance"){
    if(!is.null(pca)){
      t.connect <- lapply(1:length(neighborhoods[haspval]),
                        FUN=function(PG) {
                          x.pcs <- pca[neighborhoods[haspval][[PG]], ]
                          x.euclid <- as.matrix(dist(x.pcs))
                          x.distdens <- 1/mean(x.euclid[lower.tri(x.euclid, diag=FALSE)])
                        return(x.distdens)})
    } else{
      stop("A matrix of PCs is required to calculate distances")  
    }
  }else{
    stop("connectivity option not recognised - must be either edge, vertex or distance")
  }
  
  # use 1/connectivity as the weighting for the weighted BH adjustment from Cydar
  w <- 1/unlist(t.connect)
  w[is.infinite(w)] <- 0
  
  # Computing a density-weighted q-value.
  o <- order(pvalues)
  pvalues <- pvalues[o]
  w <- w[o]
  adjp <- numeric(length(o))
  adjp[o] <- rev(cummin(rev(sum(w)*pvalues/cumsum(w))))
  adjp <- pmin(adjp, 1)
  if (!all(haspval)) {
    refp <- rep(NA_real_, length(haspval))
    refp[haspval] <- adjp
    adjp <- refp
    }
  return(adjp)
}

# testQLF <- function(graph, nh_counts, th.model, connectivity='edge', pca=NULL){
nh_counts <- milo@neighbourhoodCounts

dge <- DGEList(nh_counts[, rownames(th.model)], lib.size=log(colSums(nh_counts)))
dge <- estimateDisp(dge, th.model)

fit <- glmQLFit(dge, th.model, robust=TRUE)
# sim2.contrast <- makeContrasts(ConditionA - ConditionB, levels=th.model)
#   sim2.res <- glmQLFTest(sim2.fit, contrast=sim2.contrast)
milo_res <- as.data.frame(topTags(glmQLFTest(fit, coef=1), sort.by='none', n=Inf))
milo_res$Sig <- as.factor(as.numeric(milo_res$FDR <= 0.05))
milo_res$Neighbourhood <- as.numeric(rownames(milo_res))
  
sim2.spatialfdr <- graph_spatialFDR(neighborhoods=milo@neighbourhoods, 
                                    graph=milo@graph[["graph"]],
                                    connectivity="distance", 
                                    pvalues=milo_res$PValue,
                                    pca=reducedDim(milo,"MOFA")
                                    )

```
```{r}
milo_res_df <- data.frame(Vertex=names(milo@neighbourhoods),
                          p=milo_res$PValue, 
                          adjp=sim2.spatialfdr, 
                          logFC=milo_res$logFC, 
                          adjp_fdr=milo_res$FDR, 
                          Sig=milo_res$Sig
                          )



milo_res_df %>%
  ggplot(aes(logFC, -log10(adjp))) +
  geom_point(size=0.1)
```


```{r}
hist(milo$adjp, breaks=50)
```


```{r}
colData(milo)["Vertex"] <- as.character(V(graph(milo)))
colData(milo) <-
  SingleCellExperiment::colData(milo) %>%
  as.data.frame() %>%
    rownames_to_column() %>%
  left_join(milo_res_df) %>%
    column_to_rownames() %>%
  DataFrame()

```
```{r}
umap_th <- umap::umap(reducedDim(milo, "MOFA"), k=30 )
reducedDim(milo, 'UMAP') <- umap_th$layout
```
```{r}
coldata_df <- bind_cols(data.frame(colData(milo)), data.frame(reducedDim(milo, 'UMAP'))) 
```


```{r}
pl_df <- scater::plotReducedDim(milo,dimred="UMAP", colour_by = "logFC", )$data  
coldata_df %>%
  arrange(- logFC) %>%
  ggplot(aes(X1,X2)) + 
  geom_point(size=0.2, color="grey", alpha=0.5) +
  geom_point(data=. %>% filter(!is.na(logFC)), aes(color=logFC), size=1) +
  scale_color_gradient2(midpoint = 0)
  theme_dimred()

pl_df <- scater::plotReducedDim(milo,dimred="UMAP", colour_by = "adjp", )$data  
pl_df %>%
  arrange(- colour_by) %>%
  ggplot(aes(X,Y)) + 
  geom_point(size=0.2, color="grey", alpha=0.5) +
  geom_point(data=. %>% filter(!is.na(colour_by)), aes(color=-log10(colour_by))) +
  scale_color_gradient2(midpoint = 0)
  theme_dimred()

```
```{r}

```

