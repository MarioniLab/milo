---
title: "Semi-synthetic DA data - Mouse Gastrulation atlas"
output: html_notebook
---

```{r}
library(tidyverse)
library(MouseGastrulationData)
library(SingleCellExperiment)
library(scater)
library(scran)
library(bit64)

source('~/milo/notebooks/benchmark/benchmark_utils.R')
```

### Load dataset

Select samples from late time points (even number of replicates)

```{r}
AtlasSampleMetadata %>%
  arrange(stage) %>%
  mutate(sample=factor(sample, levels=unique(sample))) %>%
  ggplot(aes(stage, sample)) +
  geom_point()

late_samples <- AtlasSampleMetadata %>%
  filter(stage %in% c("E7.75", "E8.0", "E8.25", "E8.5")) %>%
  pull(sample)
```

```{r}
embryo_sce <- EmbryoAtlasData(type="processed", samples = late_samples)
```
```{r}
data.frame(colData(embryo_sce)) %>%
  ggplot(aes(as.factor(sample), as.factor(pool))) + geom_point()
```


## Preprocessing
```{r}
logcounts(embryo_sce) <- log1p(counts(embryo_sce))
## Exclude zero counts genes
keep.rows <- rowSums(logcounts(embryo_sce)) != 0
embryo_sce <- embryo_sce[keep.rows, ]

dec <- modelGeneVar(embryo_sce)
hvgs <- getTopHVGs(dec, n=5000)

## Drop cells with NAs in corrected pca (low quality)
embryo_sce <- embryo_sce[,apply(reducedDim(embryo_sce, "pca.corrected"), 1, function(x) all(!is.na(x)))]

## Run UMAP (the data has been subsetted)
# embryo_sce <- scater::runPCA(embryo_sce, subset_row=hvgs)
embryo_sce <- scater::runUMAP(embryo_sce, dimred="pca.corrected")
```

```{r, fig.height=10, fig.width=10}
singlets <- which(!(colData(embryo_sce)$doublet | colData(embryo_sce)$stripped))
plotReducedDim(embryo_sce, "UMAP", colour_by="celltype")
```

Save object 4 benchmark

```{r}
saveRDS(embryo_sce, "/nfs/team205/ed6/data/milo_benchmark/embryo_data_bm.RDS")
```



## Generate synthetic labels

make probability of being in condition 1 or 2 (Translating code from scOpenProblems)

```{r}
# Given a data_embedding, sample a simplex to weight each dimension to get a
# new PDF for each condition
# a: scaling coefficient in logit (lower a --> less extreme probabilities) 
.make_pdf <- function(data_embedding, a=0.2){
  # Create an array of values that sums to 1
  n_components = ncol(data_embedding)
  data_simplex = sort(runif(n = n_components-1))
  data_simplex = c(0, data_simplex, 1)
  data_simplex = diff(data_simplex)
  data_simplex = sample(data_simplex)
  # Weight each embedding component by the simplex weights
  sort_axis = rowSums(data_embedding * data_simplex)
  
  # Pass the weighted components through a logit
  pdf = 1/(1+exp(- a * sort_axis))
  if (sample(c(TRUE, FALSE), 1)){ pdf = 1 - pdf }
  return(pdf)  
  }

## Smooth probabilities over KNN graph (to avoid having clusters with opposite sign DA)
.knn_smoothing <- function(graph, cond_probability, k=15, redDim='pca.corrected', d=10){
  # X_red_dim = reducedDim(sce, redDim)[,1:d]
  # graph = buildKNNGraph(t(X_red_dim), k = k)  
  adj = get.adjacency(graph)
  smooth_cond_probability <- (adj %*% cond_probability)/rowSums(adj)
  smooth_cond_probability
}

# Creates random differentially expressed regions over a dataset for benchmarking.
add_synthetic_labels <- function(sce, # SingleCellExperiment obj
                                 knn_graph, # for knn smoothing of probability values
                                 redDim='pca.corrected', # embedding to use to simulate differential abundance
                                 n_conditions=2, # number of conditions to simulate
                                 n_components=10, # number of components of embedding to use
                                 seed=42
                                 ){
  data_embedding = reducedDim(sce, redDim)[,1:n_components]
  set.seed(seed)
  # embedding data must be mean-centered
  data_embedding = t(scale(t(data_embedding), scale=FALSE))
  
  # Randomly flip sign of each embedding dimension
  data_embedding = apply(data_embedding, 2, function(x)  x*sample(c(-1, 1), 1) )
  
  conditions = paste0("Condition", 1:n_conditions)
  cond_probability = sapply(1:(length(conditions)-1), function(x) .make_pdf(data_embedding))
  
  # KNN Smoothing to avoid regions of the graph with opposite labels
  cond_probability = .knn_smoothing(knn_graph, cond_probability, redDim=redDim, d=n_components)
  
  # Normalize to sum to 1 for each cell
  # cond_probability <- t(apply(cond_probability, 1, function(x) x/sum(abs(x))))
  cond_probability = cbind(cond_probability, 1 - rowSums(cond_probability))
  colnames(cond_probability) = conditions
  
  # Generate labels for condition and replicates
  synth_labels <- sapply(1:nrow(cond_probability),  function(i) sample(colnames(cond_probability), size = 1, prob = cond_probability[i,]))
  synth_replicates <- rep(c("R1", "R2", "R3" ), 1000)
  synth_samples <- paste0(synth_labels, "_", synth_replicates)
  
  # Add synthetic labels and probabilities to colData
  colData(sce)[["synth_labels"]] <- synth_labels
  # colData(sce)[["synth_replicates"]] <- synth_replicates
  colData(sce)[["synth_samples"]] <- synth_samples
  colnames(cond_probability) <- paste0(colnames(cond_probability), "_prob")
  colData(sce)[colnames(cond_probability)] <- cond_probability
  return(sce)
  }

# Build KNN graph for smoothing
X_red_dim = reducedDim(embryo_sce, "pca.corrected")[,1:50]
graph = buildKNNGraph(t(X_red_dim), k = k)  

embryo_sce <- add_synthetic_labels(embryo_sce, n_components = 10,  redDim='pca.corrected', seed=42, knn_graph = graph)
```


```{r, fig.width=10, fig.height=6}
plotReducedDim(embryo_sce, "UMAP", colour_by="Condition1_prob", point_size=0.1) 
plotReducedDim(embryo_sce, "UMAP", colour_by="Condition2_prob", point_size=0.1) 

plotReducedDim(embryo_sce, "UMAP", colour_by="synth_labels", point_size=0.1) + facet_wrap(colour_by~.)
plotReducedDim(embryo_sce, "UMAP", colour_by="synth_samples", point_size=0.1) 

true_labels <- ifelse(embryo_sce$Condition2_prob < 0.4, "NegLFC", ifelse(embryo_sce$Condition2_prob > 0.6, "PosLFC", "NotDA"))
colData(embryo_sce)[["true_labels"]] <- true_labels
plotReducedDim(embryo_sce, "UMAP", colour_by="true_labels", point_size=0.1) 

```

## Picking parameters

Test how robust alternative methods are to parameter choices
```{r}
## Run MELD
bm_meld <- function(sce, k, d){
  meld_res <- run_meld_reticulate(sce, condition_col="synth_labels", sample_col="synth_samples", reduced.dim = "pca.corrected", d=d, k=k)
  meld_out <- meld2output(meld_res, out_type = 'labels')
  bm <- data.frame(meld=meld_out)
  bm$true_prob <- sce$Condition2_prob 
  bm$true <- sce$true_labels
  long_bm <- pivot_longer(bm, cols = c(meld), names_to='method', values_to="pred") 
  long_bm$k <- k
  long_bm$d <- d
  long_bm
}

true_labels <- ifelse(embryo_sce$Condition2_prob < 0.4, "NegLFC", ifelse(embryo_sce$Condition2_prob > 0.6, "PosLFC", "NotDA"))
colData(embryo_sce)[["true_labels"]] <- true_labels

meld_bm_ls <- lapply(c(10,15,20), function(k) bm_meld(embryo_sce, k, 30))

```

## Benchmark on synthetic labels

```{r}
long_bm <- benchmark_da(embryo_sce, out_type = "labels")


```

```{r, fig.width=10, fig.height=3}
long_bm %>%
  ggplot(aes(true, pred)) + 
  geom_bin2d() +
  facet_wrap(method~.)

```

```{r}
long_bm %>%
  ggplot(aes(pred, true_prob)) + 
  # ggbeeswarm::geom_quasirandom() +
  geom_boxplot(varwidth=TRUE) +
  # geom_violin() +.
  facet_wrap(method~.)

```
```{r}
calculate_outcome(long_bm)
```

Change threshold for significance in true label definition

```{r}
long_bm <- mutate(long_bm, true=ifelse(true_prob < 0.4, "NegLFC", ifelse(true_prob > 0.6, "PosLFC", "NotDA")))

calculate_outcome(long_bm)
```

## Add batch effect

Problems:
* I don't have batch corrected counts here, I need to add batch effects to PCs 

```{r}
add_batch_effect <- function(embryo_sce, norm_sd=0.5, seed=42){
  cellids_sample <- split(embryo_sce$cell, embryo_sce$synth_samples)
  X_pca <- reducedDim(embryo_sce, "pca.corrected")
  X_pca_batch <- X_pca
  
  set.seed(42)
  for (b in names(cellids_sample)){
    batch_effect <- rnorm(ncol(X_pca), mean=0, sd = norm_sd)
    X_pca_batch[cellids_sample[[b]],] <- t(apply(X_pca_batch[cellids_sample[[b]],], 1, function(x) x + batch_effect))
    }
  
  reducedDim(embryo_sce, "pca_batch") <- X_pca_batch
  embryo_sce  
  }

# plotReducedDim(embryo_sce, "pca.corrected", colour_by="synth_samples", ncomponents = 1:2, point_size=0.2) 
```


```{r}
embryo_sce <- scater::runUMAP(embryo_sce, dimred="pca_batch", name = 'umap_batch', n_dimred=1:30)

plotReducedDim(embryo_sce, "umap_batch", colour_by="Condition2_prob", point_size=0.1) 
plotReducedDim(embryo_sce, "umap_batch", colour_by="synth_labels", point_size=0.1) + facet_wrap(colour_by~.)
plotReducedDim(embryo_sce, "umap_batch", colour_by="synth_samples", point_size=0.1) 
```


```{r}
bm_batch <- benchmark_da(embryo_sce[,1:5000], red_dim = "pca_batch", out_type = "labels")
true_labels <- ifelse(embryo_sce[,1:5000]$Condition2_prob < 0.4, "NegLFC", ifelse(embryo_sce[,1:5000]$Condition2_prob > 0.6, "PosLFC", "NotDA"))
bm_batch$true_prob <- embryo_sce[,1:5000]$Condition2_prob 
bm_batch$true <- true_labels
long_bm_batch <- bm_batch %>%
  pivot_longer(cols = c(milo, daseq, meld, louvain), names_to='method', values_to="pred") 

```


```{r, fig.width=7, fig.height=5}
long_bm_batch %>%
  ggplot(aes(true, pred)) + 
  geom_bin2d() +
  facet_wrap(method~.)

```

```{r}
long_bm_batch %>%
  ggplot(aes(pred, true_prob)) + 
  # ggbeeswarm::geom_quasirandom() +
  geom_boxplot(varwidth=TRUE) +
  # geom_violin() +.
  facet_wrap(method~.)

long_bm %>%
  ggplot(aes(pred, true_prob)) + 
  # ggbeeswarm::geom_quasirandom() +
  geom_boxplot(varwidth=TRUE) +
  # geom_violin() +.
  facet_wrap(method~.)
```
```{r}
bm_ls <- lapply(c(0, 0.1, 0.5, 1), function(sd){
  sce_be <- add_batch_effect(embryo_sce, norm_sd=sd)
  long_bm <- benchmark_da(sce_be, out_type = "labels", red_dim = "pca_batch")
  # outcome <- calculate_outcome(long_bm)
  mutate(long_bm, batch_sd=sd)
  })

purrr::reduce(bm_ls, bind_rows) %>%
  ggplot(aes(batch_sd, Accuracy, color=method)) + 
  geom_point(size=3) +
  theme_bw(base_size=16)

purrr::reduce(bm_ls, bind_rows) %>%
  ggplot(aes(batch_sd, FPR, color=method)) + 
  geom_point(size=3) +
  theme_bw(base_size=16)
```


